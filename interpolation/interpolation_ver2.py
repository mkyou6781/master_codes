import numpy as np

class Interpolation:
    r"""
    generating the interpolation of a function for 
    arbitral degree and for specified degree and basis

    Parameters
    ----------
    func: function
        function to interpolate
    degree: int
        degree of interpolation
    interval: list [start, end]
        interval of the interpolation
    basis_type: "monomial" or "laglange"
        basis of the interpolant
    grid_type: "equispaced" or "chebyshev"
    output_points: int
        number of data points in the output

    Returns
    ---------
    x: numpy array 
        array of x in a fine grid
    y: numpy array
        array of interpolated value for fine grid
    grid: numpy array
        values of grid generated by either gen_equispaced_grid or gen_chevshev_grid

    """

    EPSILON = 0.03 # referred when calculating omega in Lagrange basis

    def __init__(self,func,degree,interval,basis_type,grid_type,output_points = 100):
        self.func = func
        self.degree = degree
        self.interval = interval
        self.basis_type = basis_type
        self.grid_type = grid_type
        self.output_points = output_points

    def gen_equispaced_grid(self):
        start = self.interval[0]
        end = self.interval[1]
        return np.linspace(start, end, self.degree +1, endpoint=True)

    def gen_chevshev_grid(self):
        start = self.interval[0]
        end = self.interval[1]
        num = np.arange(self.degree + 1)
        grid = start + 1/2 * (end-start) * (1 - np.cos(num * np.pi / (self.degree)))
        
        return grid
    
    def gen_data_points(self,grid):
        return self.func(grid) 

    def gen_vandermonde_matrix(self,grid):
        #vandermonde_matrix = np.zeros((self.degree,self.degree))
        powers = np.arange(self.degree + 1).reshape(1, -1)
        vandermonde_matrix = grid.reshape(-1, 1) ** powers
        self.vandermonde_matrix = vandermonde_matrix 
        return vandermonde_matrix
        
    def solve_vandermonde_matrix(self,vandermonde_matrices,data_points):
        return np.linalg.solve(vandermonde_matrices, data_points)
    
    def get_coeff(self):
        if self.grid_type == "equispaced":
            self.grid = self.gen_equispaced_grid()
        elif self.grid_type == "chebyshev":
            self.grid = self.gen_chevshev_grid()
        else:
            print("error: grid type not specified correctly")
        
        data_points = self.gen_data_points(self.grid)

        if self.basis_type == "monomial":
            vandermonde_matrix = self.gen_vandermonde_matrix(self.grid)
            coeff = self.solve_vandermonde_matrix(vandermonde_matrix, data_points)
            # np array with elements n+1
        elif self.basis_type == "lagrange":
            coeff = data_points

        else:
            print("error: basis type not specified correctly")

        self.coeff = coeff
    
    def horner_eval(self,coeff,x):
        val = coeff[self.degree]
        for i in range(self.degree):
            val = coeff[self.degree - 1 - i] + val * x
        return val
    
    def barycentric_eval(self,coeff,x):
        # evaluate interpolant with second barycentric formula
        omega_list = []
        for x_k in self.grid:
            diff = self.grid - x_k
            diff[diff == 0] = 1
            omega_inverse = np.product(diff)
            omega_list.append(1 / omega_inverse)
        omega_list = np.array(omega_list)

        if any(np.absolute(self.grid - x) < self.EPSILON):
            val = self.func(x)

        else:
            numerator = 0
            for i in range(self.degree +1):
                numerator += omega_list[i] * coeff[i] / (x - self.grid[i])
            
            denominator = 0
            for i in range(self.degree+1):
                denominator += omega_list[i] / (x - self.grid[i])
            
            val = numerator / denominator
        
        return val

    def interpolate(self,x):
        if self.basis_type == "monomial":
            val = self.horner_eval(self.coeff,x)
        elif self.basis_type == "lagrange":
            val = self.barycentric_eval(self.coeff,x)
        return val
    
    def main(self):
        #function to interpolate the given function and return the output corresponding interval
        self.get_coeff()
        
        start = self.interval[0]
        end = self.interval[1]
        x = np.linspace(start, end, self.output_points)
        y = [self.interpolate(x_val) for x_val in x]
        #to plot the function outside of the boundary for curiosity
        self.x_out = np.linspace(start-1, end+1, self.output_points)
        self.y_out = [self.interpolate(x_val) for x_val in self.x_out]

        return (x,y,self.grid)
